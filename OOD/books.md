The Cathedral and the Bazaar | No Silver Bullet

# The Cathedral and the Bazaar

## 1
No need to start from scratch; using existing code is fine and will evolve. The original code might or not go away during the journey, it does not matter.

Requirements are not clear even if they are coming from you. You will need to implement a part of your initial idea or even the whole idea before realizing what the next destination should be.

Motivation comes and goes. Maintaining code requires motivation. Today, you might maintain a piece of code, and tomorrow someone else.

Users mirror the success of your application. In an open-source world, reflections can also contribute.

Releasing often leverages users' feedback. The more you get early, the easier you can adapt.

Communication needs to be open and efficient. Encouraging people to give opinions and bugs easily. People who participate must be valued.

Get ideas from your users and remove ideas that are not anymore relevant.

When starting a project, it might be hard to use a Bazaar style; rather create something that can run to convince people to use.

The Bazaar model works well with the egoless programming

The paper ends with a talk about Netscape becoming Mozilla to dethrone Microsoft. I personally think it did not age well. Now, Google is a (mostly) a monopoly with Chrome (not fully open-source) and Mozilla's share of the markt is very small. I personnaly think the author is conflicting its ideology of open-source and how it can affect a market.

The article is fine but also has a strong bias. For example, Linus is well known to be very harsh and not really friendly to work with. Also, open-source projects are yes collaborative but there are few people who contribute to a huge majority of each project, this is also true for Linux. The paper does not talk about these two details which seem to be important in a Bazaar methodology.

## 2
This book was an interesting one.  I read this book 5 years ago, oddly enough when I was taking an elective class while I was getting my bachelor's degree in biochemistry.  Fast forward 5 years into the future, and here I am delving back into this interesting book.

An interesting point that I found in the book was how Linux spawned sort of out of the opportunity of thinking about how to allow any user to contribute to a system, regardless of the types of projects.  This led to the idea of open-source projects based on Linux.  

Given my background in chemistry and biochemistry, I always found reading scientific literature to be a hit or miss when it came to truly being able to work on experiments that others had previously worked on.  With respect to open-source projects or the computing industry as a whole, I find things to be a bit different compared to the life science industry.  In the life science industry, I found it a bit more difficult to work around ways to understand researchers' work, specifically due to many of the experiments being proprietary.  

With so many unknowns in the life science industry, especially when people with mal intent get their hands on research that can have devastating effects, I know with certainty that the open-source mentality that was described in The Cathedral and the Bazaar definitely cannot be applied to various life science experiments that are currently being conducted or will be in the future.  Unfortunately, the secrecy of the scientific components in various life science experiments leads many people to question what exactly the makers of these technologies and conductors of experiments intend to do with the things they are working on.

What I believe scientific researchers can learn from is by taking the very ideas presented in The Cathedral and the Bazaar, specifically when it relates to conducting open-source projects, and applying them to their own research.  But there in lies a paradox of some sort.  If there were to be more open source projects in the life science industry, will there be more meaningful and beneficial progress being made to improve people's lives, or will nefarious people with mal intent continue to reap in the benefits of implementing work that in turn causes more problems rather than solving many issues that affect people today?  Only time will tell.  But for now, industries of different types (i.e. industries dealing with blockchain and cryptocurrency) can possibly benefit from adopting certain aspect of the open-source concept presented in the Cathedral and the Bazaar. 

# No Silver Bullet
## 1
The difficulty in software is the specification, design, and testing; not the labor.

The complexity comes from not having two systems the same; always making new parts.

One issue in software is the constant changeability. Nothing is stable from the specification to the code.

The lack of visibility outside the code on a software increase the complexity of how to understand how the software works.

There are three methodologies that help: using a high-level language to reduce low-level complexity. Then, the use of time-sharing means avoiding interruption when working. Finally, the unified tooling reduces the difficulty to develop.

One solution provided is to buy instead of building

There is a mention to create rapid prototyping which embraces the idea of the previous paper. The reason is to know more accurately what to build.

The article is also dated in my opinion but describes many good points about the complexity and how to diminish the issue with solutions that we use now in all our development lifecycle. 

Both papers emphasize the concept of iteration, rapid development, getting the user to touch the project quickly to get feedback. In my opinion, it makes sense. I also agree that most people have a hard time expressing what they need. Hence, having a short cycle to have something running even if not perfect is reasonable. The cost might seem high to redo a portion of the features and codes but is lower than planning/designing/etc for months before executing.

## 2
This was the first time I read No Silver Bullet.  The main takeaway I found from it was the concept of accidental and essential complexities.  Just like my explanation in my summary of The Cathedral and the Bazaar, I can also apply to concept of accidental and essential complexities to the life science industry.  

A personal example I can share regarding an accidental complexity is when I worked on the synthesis of a small molecule inhibitor for a protein that inhibits the DNA repair pathway in our cells.  While the purpose of the project was to have this inhibitor function as an anti-cancer therapeutic, I came across the accidental complexity of causing myself more problems than intended.  

While working on the synthesis of the inhibitor, I caused more issues within the synthesis route because certain aspects of it degraded other vital pathways in the DNA repair mechanisms in the body (when the inhibitor was eventually synthesized as a starting material and test in vivo).  While not intended, I caused myself more issues when synthesizing the inhibitor than I intended, and as such, major portions of the synthesis had to be scrapped and redesigned in order to significantly minimize the issues that it was causing to other pathways related to the intended purpose of what the inhibitor was not supposed to accomplish.

The essential complexity that I faced with this inhibitor project was the fact that I still needed to get to the end result of synthesizing the inhibitor.  Many of the steps were unavoidable in the synthesis route, and as such, the essential complexity loomed large.  The important intermediate steps still needed to be taken, even though some steps overall caused issues and were a type of accidental complexity.  In my case, the essential complexity was more or less straightforward to understand because when performing the synthesis steps, the intermediates were either produced and properly characterized, or they weren't.  

The main parallels between the work I did with relation to accidental and essential complexities can be compared to the same complexities pointed out in the software industry, as pointed out in No Silver Bullet.  Even though the situations were different, reading No Silver Bullet gave me a great appreciation to take into account these same two types of complexities for future work, likely in the software industry.
